'use strict';(function(){const indexCfg={};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create(indexCfg);window.geekdocSearchIndex=index;index.add({'id':0,'href':'/Algoritmos-de-ordenamiento/','title':"Algoritmos de ordenamiento",'content':" Table of Contents  Acerca de Algoritmos de fuerza bruta Algoritmos de \u0026ldquo;decrecer y conquistar\u0026rdquo;    Acerca de Cada algoritmo de ordenamiento tiene su forma de operar, y podr칤a ayudar a conseguir la respuesta a un problema, no necesariamente por el resultado del ordenamiento.\nAlgoritmos de fuerza bruta Acerca de Rellenar\nBubble sort  Se van comparando los elementos, haciendo que los m치s grandes suban en el arreglo, como una burbuja. Da lo mismo c칩mo est칠n ordenadas las cosas, porque puedes modificar la funci칩n de comparaci칩n. Funciona invirtiendo el orden de cada par de elementos, si es que el primero es mayor que el segundo. Por ejemplo, se podr칤a usar para contar el n칰mero de inversiones que hay que hacer.  Ejemplo    5 3 4 1     3 5 4 1   3 4 5 1   3 4 1 5   3 4 1 5   3 1 4 5   3 1 4 5   3 1 4 5   1 3 4 5   1 3 4 5    C칩digo de ejemplo: void bubblesort (vector\u0026lt;int\u0026gt; \u0026amp;vec) { int size = vec.size(); for (int i = size-1; i \u0026gt; 0; --i) { for (int j = 0; j \u0026lt; i; ++j) { if (vec[j] \u0026gt; vec[j+1]) { int aux = vec[j]; vec[j] = vec[j+1]; vec[j+1] = aux; } } } return; } Insertion sort  Se va de izquierda a derecha, se compara el segundo con el primero, se intercambian si el segundo es menor, si este es el caso, se vuelve a preguntar si el de la izquierda es menor al de mas a la izquierda y as칤 hasta que se encuentre un caso en el que no o se llegue al principio del arreglo.  Rellenar ejemplo Rellenar codigo de ejemplo Algoritmos de \u0026ldquo;decrecer y conquistar\u0026rdquo; Acerca de Rellenar\nSelection sort  Tiene dos sub-arreglos, uno de elementos ya ordenados y uno de los elementos resantes. El arreglo ya ordenado parte vac칤o. Busca el valor m칤nimo entre los elementos no ordenados y lo a침ade al final de los ordenados.  Rellenar ejemplo Rellenar codigo de ejemplo "});index.add({'id':1,'href':'/Algoritmos-de-ordenamiento/info/','title':"Acerca de",'content':"Cada algoritmo de ordenamiento tiene su forma de operar, y podr칤a ayudar a conseguir la respuesta a un problema, no necesariamente por el resultado del ordenamiento.\n"});index.add({'id':2,'href':'/estructuras-de-datos/estructuras-lineales/','title':"Estructuras lineales",'content':" Table of Contents  Acerca de Arrays (arreglos) Arrays multidimensionales Vectors (vectores) Stacks (pilas) Queues (colas)    Acerca de Rellenar p치gina\nArrays (arreglos) Los arrays son conjuntos de datos que se almacenan en memoria de manera contigua usando el mismo nombre. Se usan 칤ndices para diferenciar los distintos valores del arreglo. Para crear una arreglo es necesario saber la cantidad de elementos que van a componer nuestro arreglo, pues la cantidad de elementos no se puede cambiar. Una cosa muy importante que al principio uno suele olvidar es que los 칤ndices de los arreglos parten en 0. Es decir, un arreglo de tama침o n puede tomar 칤ndices desde el 0 hasta el n-1.\nInicializaci칩n Hay dos formas de inicializar un array, especificando su tama침o o llenandolo con valores por defecto.\nInicializar un array por su tama침o Para inicializar un array por su tama침o, lo 칰nico que hay que especificar es el nombre de la variable y colocar entre \u0026ldquo;[]\u0026rdquo; el tama침o de nuestro arreglo. Recordar que como los arrays parten en 0, el valor m치ximo que podremos acceder ser치 el tama침o del array menos 1.\n1  int arreglo[38]; // Inicializar un arreglo de ints de tama침o 38.    Inicializar un array con valores por defecto Para inicializar un array con valores por defecto, no es necesario especificar el tama침o de nuestro array, pues este est치 impl칤cito en la cantidad de valores que introducimos.\n2  int arreglo2[] = {3, 6, 2, 1};    Leer el valor de un arreglo Para leer un valor de nuestro arreglo, solo hay que especificar el nombre del arreglo y su 칤ndice. Notar que s칩lo se puede acceder a un valor de un arreglo a la vez.\narreglo2[3]; // Retorna 1 Asignar valores a un arreglo Para esto, hay que especificar la variable, el 칤ndice al cu치l acceder y especificar su nuevo valor. Recordar que el valor del 칤ndice puede ser una variable, pero que no puede estar fuera del rango del tama침o de nuestro arreglo.\n3  arreglo2[3] = 5; // El indice 3 de nuestro arreglo, ahora tiene el valor 3    Arrays multidimensionales Un array multidimensional es aquel que requiuere de m치s de un 칤ndice para ser llamado, como su nombre lo indica, es 칰til para cuando necesitamos acceder a datos que requieren m치s de una dimensi칩n, como por ejemplo valores dentro de una malla. Otra forma de enternder los arrays multidimensionales es como un arreglo de arreglos (de arreglos de arreglos.. n veces, siendo n la cantidad de dimensiones). Los arreglos de 2 dimensiones tambi칠n son conocidos como matrices.\nInicializar un arreglo multidimensional Para esto, hay que especificar el tama침o de cada dimensi칩n del array. Notar que la regla de que empiezan en 0 y terminan en n-1 se sigue cumpliendo. Es posible asignarles valores predeterminados, pero creo que eso se va poniendo exponencialmente m치s psic칩pata a medida de que vas incrementando las dimensiones del array a crear, por lo que no lo voy a demostrar.\n1 2  int matriz[3][4]; int tridimensional[100][100][100];    Asignar valores en un arreglo multidimensional Es muy similar a c칩mo se hace en un arreglo unidimensional, solo que se especifica cada 칤ndice.\n3 4 5  int n = 3, m = 5; matriz[2][1] = 10; tridimensional[n][m] = 4;    Vectors (vectores) Los vectores son como arreglos, excepto de que el tama침o es din치mico, es decir, se puede cambiar.\nInicializar un vector Incluimos la librer칤a:\n1  #include \u0026lt;vector\u0026gt;   Inicializamos nuestro vector \u0026ldquo;vec\u0026rdquo;:\n2 3  int n = 3; vector \u0026lt; int \u0026gt; vec(n, 0); // Inicializa un vector de tama침o 3 con todos sus valores = 0. Tanto el tama침o como valor son opcionales.    Asignar un valor 4  vec[2] = 1; // Asigna el valor \u0026#34;1\u0026#34; al 칤ndice 2 (es decir, al 3er valor del vector)    push back (empujar atr치s) Si no sabemos el tama침o de nuestro vector, podemos simplemente usar push_back(valor); para enviar es valor al final del vector.\n5  vec.push_back(1); // Inserta un 1 al final del vector    Por ejemplo, se podr칤a usar en un for, sin necesidad de inicializar el vector con una cantidad de valores.\n6 7 8 9 10 11 12 13  vector \u0026lt;int\u0026gt; vec2; int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++i){ int valor; cin \u0026gt;\u0026gt; valor; vec2.push_back(); }    pop back (quitar atr치s) Elimina el 칰ltimo valor del vector.\n14  vec.pop_back(); // En este caso, elimina el 1    insert (insertar) Podemos insertar un valor entre dos indices de un vector. El problema de esto es que mueve todos los valores que est칠n m치s adelante, lo que es lento.\n15  vec.insert(vec.begin() + 2, 4); // Inserta el valor 4 al 칤ndice 2    erase (borrar) Borra un dato del vector. Al igual que el insert, tiene que mover todos los datos siguientes (esta vez a la derecha).\n16  vec.erase(vec.begin() + 2); // Elimina el valor con 칤ndice 2, en nuestro caso, el 4 que insertamos antes.    Iteradores de un arreglo Hay ciertos iteradores que podemos usar en un arreglo que nos ayudar치n en algunos casos, como por ejemplo si quieremos recorrer un arreglo. Estos son:\n begin() \u0026ndash; Iterador que accede al primer valor del arreglo. end() \u0026ndash; Accede al final del arreglo. rbegin() \u0026ndash; Accede al ultimo elemento del arreglo rend \u0026ndash; Accede al inicio del arreglo  Stacks (pilas) La pila es una estructura de datos lineal al que s칩lo puedes acceder al 칰ltimo elemento que fue insertado. Imagina una pila de platos, por ejemplo.\n1  stack \u0026lt; int \u0026gt; pilita;    push (empujar) Empuja un dato a la cima de la pila.\n2  pilita.push(8); // Empuja un 8 a la cima de la pila.    top (cima) Lee lo que hay en la cima de la pila.\n3  pilita.top(); // Retorna el 8.    pop (quitar) Remueve el dato de la cima de la pila.\n4  pilita.pop(); // Remueve el 8.    empty (vac칤o) Retorna 1 si la pila est치 vac칤a, de lo contrario retorna 0.\n5  pilita.empty(); // Retorna 1 ya que nuestra pila est치 vac칤a.    size (tama침o) Retorna el tama침o de nuestra pila.\n6  pilita.size(); // Retorna 0 ya que nuestra pila no tiene datos.    Queues (colas) La cola es una estructura de datos lineal al que s칩lo puedes acceder al primer elemento que fue insertado. Imagina una fila de una caja de un supermercado, por ejemplo.\n1  queue \u0026lt; int \u0026gt; colita;    push (empujar) A침ade un dato al final de la cola.\n2 3 4 5 6  colita.push(5); colita.push(4); colita.push(3); colita.push(2); colita.push(1);    front (frente) Lee el dato que est치 al frente de la cola.\n7  colita.front(); // Retorna 5, ya que fue lo primero que empujamos a la cola.    pop (quitar) Remueve el dato que est치 al frente de la cola\n8 9  colita.pop(); // Remueve el 5 colita.front(); // Retorna 4, ya que fue lo segundo que empujamos a la cola (y que ahora est치 primero).    empty (vac칤o) Retorna 1 si la cola est치 vac칤a, de lo contrario retorna 0.\n10  colita.empty(); // Retorna 1 ya que nuestra cola est치 vac칤a.    size (tama침o) Retorna el tama침o de nuestra cola.\n11  colita.size(); // Retorna 0 ya que nuestra cola no tiene datos.    "});index.add({'id':3,'href':'/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/','title':"Algoritmos de fuerza bruta",'content':" Table of Contents  Acerca de Bubble sort Insertion sort    Acerca de Rellenar\nBubble sort  Se van comparando los elementos, haciendo que los m치s grandes suban en el arreglo, como una burbuja. Da lo mismo c칩mo est칠n ordenadas las cosas, porque puedes modificar la funci칩n de comparaci칩n. Funciona invirtiendo el orden de cada par de elementos, si es que el primero es mayor que el segundo. Por ejemplo, se podr칤a usar para contar el n칰mero de inversiones que hay que hacer.  Ejemplo    5 3 4 1     3 5 4 1   3 4 5 1   3 4 1 5   3 4 1 5   3 1 4 5   3 1 4 5   3 1 4 5   1 3 4 5   1 3 4 5    C칩digo de ejemplo: void bubblesort (vector\u0026lt;int\u0026gt; \u0026amp;vec) { int size = vec.size(); for (int i = size-1; i \u0026gt; 0; --i) { for (int j = 0; j \u0026lt; i; ++j) { if (vec[j] \u0026gt; vec[j+1]) { int aux = vec[j]; vec[j] = vec[j+1]; vec[j+1] = aux; } } } return; } Insertion sort  Se va de izquierda a derecha, se compara el segundo con el primero, se intercambian si el segundo es menor, si este es el caso, se vuelve a preguntar si el de la izquierda es menor al de mas a la izquierda y as칤 hasta que se encuentre un caso en el que no o se llegue al principio del arreglo.  Rellenar ejemplo Rellenar codigo de ejemplo "});index.add({'id':4,'href':'/estructuras-de-datos/estructuras-de-arboles/','title':"Estructuras en forma de 치rbol",'content':" Table of Contents  Acerca de Set (conjunto) Map (mapa, tabla de hashing)    Acerca de V칠ase: arbol binario\nSet (conjunto) Es una lista que no permite que hayan elementos repetidos.\nInicializaci칩n Incluimos la librer칤a:\n1  #include \u0026lt;set\u0026gt;   Inicializamos nuestro conjunto:\n2  set \u0026lt; int \u0026gt; conjunto; // int puede ser reemplazado con cualquier otro tipo de dato    insert (Insertar) Inserta un dato. Retorna un par de elementos, el primero siendo el iterador del valor insertado y el segundo siendo un bool que marca si es que ya exist칤a o no. En el ejemplo de abajo, usamos .second para comprobar si se insert칩 correctamente o no.\n3 4 5 6 7 8 9  if (conjunto.insert(10).second) // Retorna TRUE ya que no estaba anteriormente  cout \u0026lt;\u0026lt; \u0026#34;ganai\\n\u0026#34;; if (conjunto.insert(10).second); // Retorna FALSE ya que ya hab칤a un 10. cout \u0026lt;\u0026lt; \u0026#34;no ganai\\n\u0026#34;; conjunto.insert(20); conjunto.insert(40); conjunto.insert(30); conjunto.insert(11);    find (Encontrar) Busca un elemento en el set y si lo encuentra retorna un iterador al valor. De lo contrario, retorna conjunto.end();\n10 11  if (conjunto.find(10) != conjunto.end()) cout \u0026lt;\u0026lt; \u0026#34;ganai\\n\u0026#34;;    erase (borrar) Puedes borrar un valor si le entregas el iterador al valor.\n12 13 14  set \u0026lt; int \u0026gt;::iterator it = conjunto.find(11); if (it != conjunto.end()) conjunto.erase(it);    Iterar a trav칠s de un conjunto Puedes iterar a trav칠s de un conjunto con los valores ya ordenados con un iterador:\n15 16 17 18  // Imprime 10 11 20 30 40 for (it = conjunto.begin(); it != conjunto.end(); ++it) cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;    Map (mapa, tabla de hashing) Toma dos datos, una llave y un valor. Puedes buscar una llave en tiempo logar칤tmico con la implementaci칩n de la STL. Pero con otras implementaciones se puede hacer en tiempo constante. Las llaves no se pueden repetir.\nEjemplo cotidiano Libros:\n   T칤tulo (Llave) Autor (Valor)     The C Programming Language Brian Keringhan   The AWK Programming Language Brian Keringhan   1984 George Orwell    Curso:\n   Apellido Cantidad de alumnos con el apellido     Gonzalez 3   Perez 2    Inicializar Incluimos la librer칤a de map:\n1  #include \u0026lt;map\u0026gt;   Inicializamos el mapa curso:\n2  map\u0026lt;string, int\u0026gt; curso;    Insert (insertar) Forma 1:\n3  curso[\u0026#34;perez\u0026#34;] = 1;    Forma 2:\n4  curso.insert(pair\u0026lt;string, int\u0026gt;(\u0026#34;gonzalez, 3\u0026#34;));    Operar con los valores Se puede operar con el valor tomando la llave. Ejemplo 1:\n5  ++curso.[\u0026#34;perez\u0026#34;]; // Incrementar el valor de la llave perez, por ejemplo.    Ejemplo 2:\n6  cout \u0026lt;\u0026lt; curso.[\u0026#34;perez\u0026#34;] \u0026lt;\u0026lt; endl; // El output ser치 2.    Cuidado con operar con valores no existentes, pues los inicializar치 de una forma inesperada.\nFind (encontrar) Retorna un iterador, si no lo encuentra, apunta a map.end() Asignamos el iterador it a gonzalez, y luego lo usamos:\n7 8 9 10 11 12 13  map\u0026lt;string, int\u0026gt;::iterator it; it = curso.find(\u0026#34;gonzalez\u0026#34;); if (it != curso.end()){ cout \u0026lt;\u0026lt; \u0026#34;Hay \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; en el curso:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Llave: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; Valor: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }    Podemos incluso operar usando los iteradores:\n14  it-\u0026gt;++second;    Erase (borrar) Forma 1:\n15 16  it = curso.find(\u0026#34;perez\u0026#34;); curso.erase(it);    Forma 2:\n17  curso.erase(\u0026#34;gonzalez\u0026#34;);    Recorrer los valores de un mapa Es exactamente igual que en un conjunto:\n18 19 20  for (it = curso.begin(); it != curso.end(); ++it){ cout \u0026lt;\u0026lt; \u0026#34;Llave: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; Valor: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }    Dudas que no dejan dormir 쯈u칠 pasa si modifico una llave? No se puede, tu c칩digo no compilar치 pues es ilegal hacerlo 游놅游뚭游뚿\n쯇uedo buscar con el second? No, en ese caso recomendamos otra estructura, o tener dos maps 游\n쯇uedo tener un map dentro de un map? Si, pero es de psic칩pata buscar dentro de ese map.\n"});index.add({'id':5,'href':'/Algoritmos-de-ordenamiento/Algoritmos-de-decrecer-y-conquistar/','title':"Algoritmos de \"decrecer y conquistar\"",'content':" Table of Contents  Acerca de Selection sort    Acerca de Rellenar\nSelection sort  Tiene dos sub-arreglos, uno de elementos ya ordenados y uno de los elementos resantes. El arreglo ya ordenado parte vac칤o. Busca el valor m칤nimo entre los elementos no ordenados y lo a침ade al final de los ordenados.  Rellenar ejemplo Rellenar codigo de ejemplo "});index.add({'id':6,'href':'/Algoritmos-de-ordenamiento/Algoritmos-de-decrecer-y-conquistar/info/','title':"Acerca de",'content':"Rellenar\n"});index.add({'id':7,'href':'/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/info/','title':"Acerca de",'content':"Rellenar\n"});index.add({'id':8,'href':'/estructuras-de-datos/estructuras-de-arboles/info/','title':"Acerca de",'content':"V칠ase: arbol binario\n"});index.add({'id':9,'href':'/estructuras-de-datos/estructuras-lineales/info/','title':"Acerca de",'content':"Rellenar p치gina\n"});index.add({'id':10,'href':'/estructuras-de-datos/estructuras-lineales/arrays/','title':"Arrays (arreglos)",'content':" Table of Contents  Inicializaci칩n Leer el valor de un arreglo Asignar valores a un arreglo    Los arrays son conjuntos de datos que se almacenan en memoria de manera contigua usando el mismo nombre. Se usan 칤ndices para diferenciar los distintos valores del arreglo. Para crear una arreglo es necesario saber la cantidad de elementos que van a componer nuestro arreglo, pues la cantidad de elementos no se puede cambiar. Una cosa muy importante que al principio uno suele olvidar es que los 칤ndices de los arreglos parten en 0. Es decir, un arreglo de tama침o n puede tomar 칤ndices desde el 0 hasta el n-1.\nInicializaci칩n Hay dos formas de inicializar un array, especificando su tama침o o llenandolo con valores por defecto.\nInicializar un array por su tama침o Para inicializar un array por su tama침o, lo 칰nico que hay que especificar es el nombre de la variable y colocar entre \u0026ldquo;[]\u0026rdquo; el tama침o de nuestro arreglo. Recordar que como los arrays parten en 0, el valor m치ximo que podremos acceder ser치 el tama침o del array menos 1.\n1  int arreglo[38]; // Inicializar un arreglo de ints de tama침o 38.    Inicializar un array con valores por defecto Para inicializar un array con valores por defecto, no es necesario especificar el tama침o de nuestro array, pues este est치 impl칤cito en la cantidad de valores que introducimos.\n2  int arreglo2[] = {3, 6, 2, 1};    Leer el valor de un arreglo Para leer un valor de nuestro arreglo, solo hay que especificar el nombre del arreglo y su 칤ndice. Notar que s칩lo se puede acceder a un valor de un arreglo a la vez.\narreglo2[3]; // Retorna 1 Asignar valores a un arreglo Para esto, hay que especificar la variable, el 칤ndice al cu치l acceder y especificar su nuevo valor. Recordar que el valor del 칤ndice puede ser una variable, pero que no puede estar fuera del rango del tama침o de nuestro arreglo.\n3  arreglo2[3] = 5; // El indice 3 de nuestro arreglo, ahora tiene el valor 3    "});index.add({'id':11,'href':'/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/bubble/','title':"Bubble sort",'content':" Table of Contents  Ejemplo C칩digo de ejemplo:     Se van comparando los elementos, haciendo que los m치s grandes suban en el arreglo, como una burbuja. Da lo mismo c칩mo est칠n ordenadas las cosas, porque puedes modificar la funci칩n de comparaci칩n. Funciona invirtiendo el orden de cada par de elementos, si es que el primero es mayor que el segundo. Por ejemplo, se podr칤a usar para contar el n칰mero de inversiones que hay que hacer.  Ejemplo    5 3 4 1     3 5 4 1   3 4 5 1   3 4 1 5   3 4 1 5   3 1 4 5   3 1 4 5   3 1 4 5   1 3 4 5   1 3 4 5    C칩digo de ejemplo: void bubblesort (vector\u0026lt;int\u0026gt; \u0026amp;vec) { int size = vec.size(); for (int i = size-1; i \u0026gt; 0; --i) { for (int j = 0; j \u0026lt; i; ++j) { if (vec[j] \u0026gt; vec[j+1]) { int aux = vec[j]; vec[j] = vec[j+1]; vec[j+1] = aux; } } } return; } "});index.add({'id':12,'href':'/Algoritmos-de-ordenamiento/Algoritmos-de-decrecer-y-conquistar/selection/','title':"Selection sort",'content':" Table of Contents  Rellenar ejemplo Rellenar codigo de ejemplo     Tiene dos sub-arreglos, uno de elementos ya ordenados y uno de los elementos resantes. El arreglo ya ordenado parte vac칤o. Busca el valor m칤nimo entre los elementos no ordenados y lo a침ade al final de los ordenados.  Rellenar ejemplo Rellenar codigo de ejemplo "});index.add({'id':13,'href':'/estructuras-de-datos/estructuras-de-arboles/set/','title':"Set (conjunto)",'content':" Table of Contents  Inicializaci칩n insert (Insertar) find (Encontrar) erase (borrar) Iterar a trav칠s de un conjunto    Es una lista que no permite que hayan elementos repetidos.\nInicializaci칩n Incluimos la librer칤a:\n1  #include \u0026lt;set\u0026gt;   Inicializamos nuestro conjunto:\n2  set \u0026lt; int \u0026gt; conjunto; // int puede ser reemplazado con cualquier otro tipo de dato    insert (Insertar) Inserta un dato. Retorna un par de elementos, el primero siendo el iterador del valor insertado y el segundo siendo un bool que marca si es que ya exist칤a o no. En el ejemplo de abajo, usamos .second para comprobar si se insert칩 correctamente o no.\n3 4 5 6 7 8 9  if (conjunto.insert(10).second) // Retorna TRUE ya que no estaba anteriormente  cout \u0026lt;\u0026lt; \u0026#34;ganai\\n\u0026#34;; if (conjunto.insert(10).second); // Retorna FALSE ya que ya hab칤a un 10. cout \u0026lt;\u0026lt; \u0026#34;no ganai\\n\u0026#34;; conjunto.insert(20); conjunto.insert(40); conjunto.insert(30); conjunto.insert(11);    find (Encontrar) Busca un elemento en el set y si lo encuentra retorna un iterador al valor. De lo contrario, retorna conjunto.end();\n10 11  if (conjunto.find(10) != conjunto.end()) cout \u0026lt;\u0026lt; \u0026#34;ganai\\n\u0026#34;;    erase (borrar) Puedes borrar un valor si le entregas el iterador al valor.\n12 13 14  set \u0026lt; int \u0026gt;::iterator it = conjunto.find(11); if (it != conjunto.end()) conjunto.erase(it);    Iterar a trav칠s de un conjunto Puedes iterar a trav칠s de un conjunto con los valores ya ordenados con un iterador:\n15 16 17 18  // Imprime 10 11 20 30 40 for (it = conjunto.begin(); it != conjunto.end(); ++it) cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;;    "});index.add({'id':14,'href':'/estructuras-de-datos/estructuras-lineales/multi-dimension-arrays/','title':"Arrays multidimensionales",'content':" Table of Contents  Inicializar un arreglo multidimensional Asignar valores en un arreglo multidimensional    Un array multidimensional es aquel que requiuere de m치s de un 칤ndice para ser llamado, como su nombre lo indica, es 칰til para cuando necesitamos acceder a datos que requieren m치s de una dimensi칩n, como por ejemplo valores dentro de una malla. Otra forma de enternder los arrays multidimensionales es como un arreglo de arreglos (de arreglos de arreglos.. n veces, siendo n la cantidad de dimensiones). Los arreglos de 2 dimensiones tambi칠n son conocidos como matrices.\nInicializar un arreglo multidimensional Para esto, hay que especificar el tama침o de cada dimensi칩n del array. Notar que la regla de que empiezan en 0 y terminan en n-1 se sigue cumpliendo. Es posible asignarles valores predeterminados, pero creo que eso se va poniendo exponencialmente m치s psic칩pata a medida de que vas incrementando las dimensiones del array a crear, por lo que no lo voy a demostrar.\n1 2  int matriz[3][4]; int tridimensional[100][100][100];    Asignar valores en un arreglo multidimensional Es muy similar a c칩mo se hace en un arreglo unidimensional, solo que se especifica cada 칤ndice.\n3 4 5  int n = 3, m = 5; matriz[2][1] = 10; tridimensional[n][m] = 4;    "});index.add({'id':15,'href':'/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/insertion/','title':"Insertion sort",'content':" Table of Contents  Rellenar ejemplo Rellenar codigo de ejemplo     Se va de izquierda a derecha, se compara el segundo con el primero, se intercambian si el segundo es menor, si este es el caso, se vuelve a preguntar si el de la izquierda es menor al de mas a la izquierda y as칤 hasta que se encuentre un caso en el que no o se llegue al principio del arreglo.  Rellenar ejemplo Rellenar codigo de ejemplo "});index.add({'id':16,'href':'/estructuras-de-datos/estructuras-de-arboles/map/','title':"Map (mapa, tabla de hashing)",'content':" Table of Contents  Ejemplo cotidiano Inicializar Insert (insertar) Operar con los valores Find (encontrar) Erase (borrar) Recorrer los valores de un mapa Dudas que no dejan dormir    Toma dos datos, una llave y un valor. Puedes buscar una llave en tiempo logar칤tmico con la implementaci칩n de la STL. Pero con otras implementaciones se puede hacer en tiempo constante. Las llaves no se pueden repetir.\nEjemplo cotidiano Libros:\n   T칤tulo (Llave) Autor (Valor)     The C Programming Language Brian Keringhan   The AWK Programming Language Brian Keringhan   1984 George Orwell    Curso:\n   Apellido Cantidad de alumnos con el apellido     Gonzalez 3   Perez 2    Inicializar Incluimos la librer칤a de map:\n1  #include \u0026lt;map\u0026gt;   Inicializamos el mapa curso:\n2  map\u0026lt;string, int\u0026gt; curso;    Insert (insertar) Forma 1:\n3  curso[\u0026#34;perez\u0026#34;] = 1;    Forma 2:\n4  curso.insert(pair\u0026lt;string, int\u0026gt;(\u0026#34;gonzalez, 3\u0026#34;));    Operar con los valores Se puede operar con el valor tomando la llave. Ejemplo 1:\n5  ++curso.[\u0026#34;perez\u0026#34;]; // Incrementar el valor de la llave perez, por ejemplo.    Ejemplo 2:\n6  cout \u0026lt;\u0026lt; curso.[\u0026#34;perez\u0026#34;] \u0026lt;\u0026lt; endl; // El output ser치 2.    Cuidado con operar con valores no existentes, pues los inicializar치 de una forma inesperada.\nFind (encontrar) Retorna un iterador, si no lo encuentra, apunta a map.end() Asignamos el iterador it a gonzalez, y luego lo usamos:\n7 8 9 10 11 12 13  map\u0026lt;string, int\u0026gt;::iterator it; it = curso.find(\u0026#34;gonzalez\u0026#34;); if (it != curso.end()){ cout \u0026lt;\u0026lt; \u0026#34;Hay \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; en el curso:\\n\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;Llave: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; Valor: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }    Podemos incluso operar usando los iteradores:\n14  it-\u0026gt;++second;    Erase (borrar) Forma 1:\n15 16  it = curso.find(\u0026#34;perez\u0026#34;); curso.erase(it);    Forma 2:\n17  curso.erase(\u0026#34;gonzalez\u0026#34;);    Recorrer los valores de un mapa Es exactamente igual que en un conjunto:\n18 19 20  for (it = curso.begin(); it != curso.end(); ++it){ cout \u0026lt;\u0026lt; \u0026#34;Llave: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;first \u0026lt;\u0026lt; \u0026#34; Valor: \u0026#34; \u0026lt;\u0026lt; it-\u0026gt;second \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; }    Dudas que no dejan dormir 쯈u칠 pasa si modifico una llave? No se puede, tu c칩digo no compilar치 pues es ilegal hacerlo 游놅游뚭游뚿\n쯇uedo buscar con el second? No, en ese caso recomendamos otra estructura, o tener dos maps 游\n쯇uedo tener un map dentro de un map? Si, pero es de psic칩pata buscar dentro de ese map.\n"});index.add({'id':17,'href':'/estructuras-de-datos/estructuras-lineales/vectors/','title':"Vectors (vectores)",'content':" Table of Contents  Inicializar un vector Asignar un valor push back (empujar atr치s) pop back (quitar atr치s) insert (insertar) erase (borrar) Iteradores de un arreglo    Los vectores son como arreglos, excepto de que el tama침o es din치mico, es decir, se puede cambiar.\nInicializar un vector Incluimos la librer칤a:\n1  #include \u0026lt;vector\u0026gt;   Inicializamos nuestro vector \u0026ldquo;vec\u0026rdquo;:\n2 3  int n = 3; vector \u0026lt; int \u0026gt; vec(n, 0); // Inicializa un vector de tama침o 3 con todos sus valores = 0. Tanto el tama침o como valor son opcionales.    Asignar un valor 4  vec[2] = 1; // Asigna el valor \u0026#34;1\u0026#34; al 칤ndice 2 (es decir, al 3er valor del vector)    push back (empujar atr치s) Si no sabemos el tama침o de nuestro vector, podemos simplemente usar push_back(valor); para enviar es valor al final del vector.\n5  vec.push_back(1); // Inserta un 1 al final del vector    Por ejemplo, se podr칤a usar en un for, sin necesidad de inicializar el vector con una cantidad de valores.\n6 7 8 9 10 11 12 13  vector \u0026lt;int\u0026gt; vec2; int n; cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; ++i){ int valor; cin \u0026gt;\u0026gt; valor; vec2.push_back(); }    pop back (quitar atr치s) Elimina el 칰ltimo valor del vector.\n14  vec.pop_back(); // En este caso, elimina el 1    insert (insertar) Podemos insertar un valor entre dos indices de un vector. El problema de esto es que mueve todos los valores que est칠n m치s adelante, lo que es lento.\n15  vec.insert(vec.begin() + 2, 4); // Inserta el valor 4 al 칤ndice 2    erase (borrar) Borra un dato del vector. Al igual que el insert, tiene que mover todos los datos siguientes (esta vez a la derecha).\n16  vec.erase(vec.begin() + 2); // Elimina el valor con 칤ndice 2, en nuestro caso, el 4 que insertamos antes.    Iteradores de un arreglo Hay ciertos iteradores que podemos usar en un arreglo que nos ayudar치n en algunos casos, como por ejemplo si quieremos recorrer un arreglo. Estos son:\n begin() \u0026ndash; Iterador que accede al primer valor del arreglo. end() \u0026ndash; Accede al final del arreglo. rbegin() \u0026ndash; Accede al ultimo elemento del arreglo rend \u0026ndash; Accede al inicio del arreglo  "});index.add({'id':18,'href':'/estructuras-de-datos/estructuras-lineales/stacks/','title':"Stacks (pilas)",'content':" Table of Contents  push (empujar) top (cima) pop (quitar) empty (vac칤o) size (tama침o)    La pila es una estructura de datos lineal al que s칩lo puedes acceder al 칰ltimo elemento que fue insertado. Imagina una pila de platos, por ejemplo.\n1  stack \u0026lt; int \u0026gt; pilita;    push (empujar) Empuja un dato a la cima de la pila.\n2  pilita.push(8); // Empuja un 8 a la cima de la pila.    top (cima) Lee lo que hay en la cima de la pila.\n3  pilita.top(); // Retorna el 8.    pop (quitar) Remueve el dato de la cima de la pila.\n4  pilita.pop(); // Remueve el 8.    empty (vac칤o) Retorna 1 si la pila est치 vac칤a, de lo contrario retorna 0.\n5  pilita.empty(); // Retorna 1 ya que nuestra pila est치 vac칤a.    size (tama침o) Retorna el tama침o de nuestra pila.\n6  pilita.size(); // Retorna 0 ya que nuestra pila no tiene datos.    "});index.add({'id':19,'href':'/estructuras-de-datos/estructuras-lineales/queues/','title':"Queues (colas)",'content':" Table of Contents  push (empujar) front (frente) pop (quitar) empty (vac칤o) size (tama침o)    La cola es una estructura de datos lineal al que s칩lo puedes acceder al primer elemento que fue insertado. Imagina una fila de una caja de un supermercado, por ejemplo.\n1  queue \u0026lt; int \u0026gt; colita;    push (empujar) A침ade un dato al final de la cola.\n2 3 4 5 6  colita.push(5); colita.push(4); colita.push(3); colita.push(2); colita.push(1);    front (frente) Lee el dato que est치 al frente de la cola.\n7  colita.front(); // Retorna 5, ya que fue lo primero que empujamos a la cola.    pop (quitar) Remueve el dato que est치 al frente de la cola\n8 9  colita.pop(); // Remueve el 5 colita.front(); // Retorna 4, ya que fue lo segundo que empujamos a la cola (y que ahora est치 primero).    empty (vac칤o) Retorna 1 si la cola est치 vac칤a, de lo contrario retorna 0.\n10  colita.empty(); // Retorna 1 ya que nuestra cola est치 vac칤a.    size (tama침o) Retorna el tama침o de nuestra cola.\n11  colita.size(); // Retorna 0 ya que nuestra cola no tiene datos.    "});index.add({'id':20,'href':'/algoritmos-de-busqueda/','title':"Algoritmos de busquedas",'content':""});index.add({'id':21,'href':'/','title':"Apuntes YoC+ Comunitarios",'content':""});index.add({'id':22,'href':'/algoritmos-de-busqueda/binary/','title':"Binary Search",'content':" Contenido  쯈u칠 es la b칰squeda binaria? Ejemplo de b칰squeda binaria Uso mediante STL Implementaci칩n con while Implementaci칩n recursiva lower_bound() en STL upper_bound() en STL    쯈u칠 es la b칰squeda binaria? La b칰squeda binaria es un algoritmo de divide and conquer, que nos permite encontrar un elemento dentro de una estructura ordenada r치pidamente. Al ejecutarse, toma el centro de un arreglo y comprueba si el valor que se busca es igual al del centro. De no serlo, verifica si el valor es menor o mayor al del centro.\nSi el valor es mayor al del centro, se ignoran todos los valores anteriores al centro, dividiendo la cantidad de n칰meros a la mitad.\nSi el valor es menor al del centro, se ignoran todos los valores de despu칠s del centro, dividiendo la cantidad de n칰meros a la mitad.\nLa dificultad de este algoritmo es O log(N), comparada con un algoritmo lineal, que en el peor de los casos tiene dificultad O (N).\nEjemplo de b칰squeda binaria Ejemplo en la vida real: Ir al medio de un diccionario, y buscar alfab칠ticamente.\nEjemplo buscando el 19: Uso mediante STL La librer칤a STL ya incluye binary search, si queremos saber si el valor 3 est치 en un vector, podemos ejecutar:\nbinary_search (v.begin(), v.end(), 3) Retorna un bool.\nImplementaci칩n con while Esta implementaci칩n nos retorna el n칰mero a buscar dentro de un arreglo.\nint binarySearch(int arr[], int l, int r, int x) { while (l \u0026lt;= r) { int m = l + (r - l) / 2; // Revisa si x esta al medio \tif (arr[m] == x) return m; // Si x es mayor, ignorar la izquierda \tif (arr[m] \u0026lt; x) l = m + 1; // Si x es menor, ignorar la derecha \telse r = m - 1; } return -1; } Implementaci칩n recursiva Esta implementaci칩n nos retorna el n칰mero a buscar dentro de un arreglo.\nint binarySearch(int arr[], int l, int r, int x) { if (r \u0026gt;= l) { int mid = l + (r - l) / 2; // Revisa si x esta al medio  if (arr[mid] == x) return mid; // Si x es mayor, ignorar la izquierda \tif (arr[mid] \u0026gt; x) return binarySearch(arr, l, mid - 1, x); // Si x es mayor, ignorar la derecha \treturn binarySearch(arr, mid + 1, r, x); } return -1; } lower_bound() en STL La funci칩n lower_bound() de la librer칤a STL retorna un puntero a un valor superior o, si es posible, igual al entregado dentro de una estructura ordenada.\nSi todos los elementos en el arreglo son inferiores al valor pedido, se entrega el 칰ltimo elemento del arreglo. Si los elementos del arreglo son superiores al valor pedido, se entrega el primer elemento del arreglo.\nEjemplo vector\u0026lt;int\u0026gt; v{ 10, 20, 30, 30, 30, 40, 50 }; *lower_bound(v.begin(), v.end(), 35); Valor de retorno: 30 (el primero en el arreglo, en la posici칩n [2])\nupper_bound() en STL La funci칩n upper_bound() de la librer칤a STL nos entrega un puntero a un valor superior al pedido en un arreglo ordenado.\nEn el caso de que no haya un valor superior al pedido, nos entrega el 칰ltimo valor del arreglo.\nEjemplo vector\u0026lt;int\u0026gt; v{ 10, 20, 30, 30, 40, 50 }; *upper_bound(v.begin(), v.end(), 30); Valor de retorno: 40 (posici칩n [4])\n"});index.add({'id':23,'href':'/categories/','title':"Categories",'content':""});index.add({'id':24,'href':'/estructuras-de-datos/','title':"Estructuras de datos",'content':""});index.add({'id':25,'href':'/tags/','title':"Tags",'content':""});})();