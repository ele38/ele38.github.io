<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Apuntes YoC&#43; Comunitarios</title>
    <link>/</link>
    <description>Recent content on Apuntes YoC&#43; Comunitarios</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-cl</language><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Acerca de</title>
      <link>/Algoritmos-de-ordenamiento/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/info/</guid>
      <description>Un algoritmo de ordenamiento es aquel que toma los elementos de una estructura y les asigna un orden. Cada algoritmo de ordenamiento tiene su forma de operar, y podría ayudar a conseguir la respuesta a un problema, no necesariamente por el resultado del ordenamiento.</description>
    </item>
    
    <item>
      <title>Acerca de</title>
      <link>/Algoritmos-de-busqueda/B%C3%BAsqueda-binaria/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-busqueda/B%C3%BAsqueda-binaria/info/</guid>
      <description>Table of Contents  Ejemplos    La búsqueda binaria es un algoritmo de divide and conquer (dividir y conquistar), que nos permite encontrar un elemento dentro de una estructura ordenada rápidamente. Al ejecutarse, toma el centro de un arreglo y comprueba si el valor que se busca es igual al del centro. De no serlo, verifica si el valor es menor o mayor al del centro.
Si el valor es mayor al del centro, se ignoran todos los valores anteriores al centro, dividiendo la cantidad de números a la mitad.</description>
    </item>
    
    <item>
      <title>Acerca de</title>
      <link>/Algoritmos-de-ordenamiento/Algoritmos-de-decrecer-y-conquistar/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/Algoritmos-de-decrecer-y-conquistar/info/</guid>
      <description>Rellenar</description>
    </item>
    
    <item>
      <title>Acerca de</title>
      <link>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/info/</guid>
      <description>Rellenar</description>
    </item>
    
    <item>
      <title>Acerca de</title>
      <link>/estructuras-de-datos/estructuras-de-arboles/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-de-arboles/info/</guid>
      <description>Véase: arbol binario</description>
    </item>
    
    <item>
      <title>Acerca de</title>
      <link>/estructuras-de-datos/estructuras-lineales/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/info/</guid>
      <description>Rellenar página</description>
    </item>
    
    <item>
      <title>Arrays (arreglos)</title>
      <link>/estructuras-de-datos/estructuras-lineales/arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/arrays/</guid>
      <description>Table of Contents  Inicialización Leer el valor de un arreglo Asignar valores a un arreglo    Los arrays son conjuntos de datos que se almacenan en memoria de manera contigua usando el mismo nombre. Se usan índices para diferenciar los distintos valores del arreglo. Para crear una arreglo es necesario saber la cantidad de elementos que van a componer nuestro arreglo, pues la cantidad de elementos no se puede cambiar.</description>
    </item>
    
    <item>
      <title>Bubble sort</title>
      <link>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/bubble/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/bubble/</guid>
      <description>Table of Contents  Ejemplo Código de ejemplo:     Se van comparando los elementos, haciendo que los más grandes suban en el arreglo, como una burbuja. Da lo mismo cómo estén ordenadas las cosas, porque puedes modificar la función de comparación. Funciona invirtiendo el orden de cada par de elementos, si es que el primero es mayor que el segundo. Por ejemplo, se podría usar para contar el número de inversiones que hay que hacer.</description>
    </item>
    
    <item>
      <title>Selection sort</title>
      <link>/Algoritmos-de-ordenamiento/Algoritmos-de-decrecer-y-conquistar/selection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/Algoritmos-de-decrecer-y-conquistar/selection/</guid>
      <description> Table of Contents  Rellenar ejemplo Rellenar codigo de ejemplo     Tiene dos sub-arreglos, uno de elementos ya ordenados y uno de los elementos resantes. El arreglo ya ordenado parte vacío. Busca el valor mínimo entre los elementos no ordenados y lo añade al final de los ordenados.  Rellenar ejemplo Rellenar codigo de ejemplo </description>
    </item>
    
    <item>
      <title>Set (conjunto)</title>
      <link>/estructuras-de-datos/estructuras-de-arboles/set/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-de-arboles/set/</guid>
      <description>Table of Contents  Inicialización insert (Insertar) find (Encontrar) erase (borrar) Iterar a través de un conjunto    Es una lista que no permite que hayan elementos repetidos.
Inicialización Incluimos la librería:
1  #include &amp;lt;set&amp;gt;   Inicializamos nuestro conjunto:
2  set &amp;lt; int &amp;gt; conjunto; // int puede ser reemplazado con cualquier otro tipo de dato    insert (Insertar) Inserta un dato. Retorna un par de elementos, el primero siendo el iterador del valor insertado y el segundo siendo un bool que marca si es que ya existía o no.</description>
    </item>
    
    <item>
      <title>Arrays multidimensionales</title>
      <link>/estructuras-de-datos/estructuras-lineales/multi-dimension-arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/multi-dimension-arrays/</guid>
      <description>Table of Contents  Inicializar un arreglo multidimensional Asignar valores en un arreglo multidimensional    Un array multidimensional es aquel que requiuere de más de un índice para ser llamado, como su nombre lo indica, es útil para cuando necesitamos acceder a datos que requieren más de una dimensión, como por ejemplo valores dentro de una malla. Otra forma de enternder los arrays multidimensionales es como un arreglo de arreglos (de arreglos de arreglos.</description>
    </item>
    
    <item>
      <title>Insertion sort</title>
      <link>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/insertion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/insertion/</guid>
      <description>Table of Contents  Rellenar ejemplo Rellenar codigo de ejemplo     Se va de izquierda a derecha, se compara el segundo con el primero, se intercambian si el segundo es menor, si este es el caso, se vuelve a preguntar si el de la izquierda es menor al de mas a la izquierda y así hasta que se encuentre un caso en el que no o se llegue al principio del arreglo.</description>
    </item>
    
    <item>
      <title>Map (mapa, tabla de hashing)</title>
      <link>/estructuras-de-datos/estructuras-de-arboles/map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-de-arboles/map/</guid>
      <description>Table of Contents  Ejemplo cotidiano Inicializar Insert (insertar) Operar con los valores Find (encontrar) Erase (borrar) Recorrer los valores de un mapa Dudas que no dejan dormir    Toma dos datos, una llave y un valor. Puedes buscar una llave en tiempo logarítmico con la implementación de la STL. Pero con otras implementaciones se puede hacer en tiempo constante. Las llaves no se pueden repetir.
Ejemplo cotidiano Libros:</description>
    </item>
    
    <item>
      <title>Vectors (vectores)</title>
      <link>/estructuras-de-datos/estructuras-lineales/vectors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/vectors/</guid>
      <description>Table of Contents  Inicializar un vector Asignar un valor push back (empujar atrás) pop back (quitar atrás) insert (insertar) erase (borrar) Iteradores de un arreglo    Los vectores son como arreglos, excepto de que el tamaño es dinámico, es decir, se puede cambiar.
Inicializar un vector Incluimos la librería:
1  #include &amp;lt;vector&amp;gt;   Inicializamos nuestro vector &amp;ldquo;vec&amp;rdquo;:
2 3  int n = 3; vector &amp;lt; int &amp;gt; vec(n, 0); // Inicializa un vector de tamaño 3 con todos sus valores = 0.</description>
    </item>
    
    <item>
      <title>Stacks (pilas)</title>
      <link>/estructuras-de-datos/estructuras-lineales/stacks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/stacks/</guid>
      <description>Table of Contents  push (empujar) top (cima) pop (quitar) empty (vacío) size (tamaño)    La pila es una estructura de datos lineal al que sólo puedes acceder al último elemento que fue insertado. Imagina una pila de platos, por ejemplo.
1  stack &amp;lt; int &amp;gt; pilita;    push (empujar) Empuja un dato a la cima de la pila.
2  pilita.push(8); // Empuja un 8 a la cima de la pila.</description>
    </item>
    
    <item>
      <title>Queues (colas)</title>
      <link>/estructuras-de-datos/estructuras-lineales/queues/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/queues/</guid>
      <description>Table of Contents  push (empujar) front (frente) pop (quitar) empty (vacío) size (tamaño)    La cola es una estructura de datos lineal al que sólo puedes acceder al primer elemento que fue insertado. Imagina una fila de una caja de un supermercado, por ejemplo.
1  queue &amp;lt; int &amp;gt; colita;    push (empujar) Añade un dato al final de la cola.
2 3 4 5 6  colita.</description>
    </item>
    
    <item>
      <title>Implementación con while</title>
      <link>/Algoritmos-de-busqueda/B%C3%BAsqueda-binaria/Implementaciones-propias/con_while/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-busqueda/B%C3%BAsqueda-binaria/Implementaciones-propias/con_while/</guid>
      <description>Esta implementación nos retorna el índice del número a buscar dentro de un arreglo.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  int binarySearch(int arr[], int l, int r, int x) { while (l &amp;lt;= r) { int m = l + (r - l) / 2; // Revisa si x esta al medio  if (arr[m] == x) return m; // Si x es mayor, ignorar la izquierda  if (arr[m] &amp;lt; x) l = m + 1; // Si x es menor, ignorar la derecha  else r = m - 1; } return -1; }    </description>
    </item>
    
    <item>
      <title>Implementación recursiva</title>
      <link>/Algoritmos-de-busqueda/B%C3%BAsqueda-binaria/Implementaciones-propias/con_recursion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-busqueda/B%C3%BAsqueda-binaria/Implementaciones-propias/con_recursion/</guid>
      <description>Esta implementación nos retorna el índice del número a buscar dentro de un arreglo.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  int binarySearch(int arr[], int l, int r, int x) { if (r &amp;gt;= l) { int mid = l + (r - l) / 2; // Revisa si x esta al medio  if (arr[mid] == x) return mid; // Si x es mayor, ignorar la izquierda  if (arr[mid] &amp;gt; x) return binarySearch(arr, l, mid - 1, x); // Si x es mayor, ignorar la derecha  return binarySearch(arr, mid + 1, r, x); } return -1; }    </description>
    </item>
    
    <item>
      <title>Importar</title>
      <link>/Algoritmos-de-busqueda/B%C3%BAsqueda-binaria/En-la-STL/importar/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-busqueda/B%C3%BAsqueda-binaria/En-la-STL/importar/</guid>
      <description>Podemos directamente importar toda la stl o podemos importar la librería  de la siguiente forma:
1  #include &amp;lt;algorithm&amp;gt;   </description>
    </item>
    
    <item>
      <title>binary_search()</title>
      <link>/Algoritmos-de-busqueda/B%C3%BAsqueda-binaria/En-la-STL/binary_search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-busqueda/B%C3%BAsqueda-binaria/En-la-STL/binary_search/</guid>
      <description>La librería STL ya incluye binary search, si queremos saber si el valor 3 está en un vector, podemos ejecutar:
1 2 3 4 5 6 7  vector&amp;lt;int&amp;gt; v{1,2,5,7}; if (binary_search (v.begin(), v.end(), 3)) { cout &amp;lt;&amp;lt; &amp;#34;Se encuentra el valor 3 en nuestro vector\n&amp;#34;; } else { cout &amp;lt;&amp;lt; &amp;#34;No hay ningún 3 en nuestro vector\n&amp;#34;; }    Retorna un bool.</description>
    </item>
    
    <item>
      <title>upper_bound() (límite superior)</title>
      <link>/Algoritmos-de-busqueda/B%C3%BAsqueda-binaria/En-la-STL/lower_bound/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-busqueda/B%C3%BAsqueda-binaria/En-la-STL/lower_bound/</guid>
      <description>La función upper_bound() de la librería STL nos entrega un puntero a un valor superior al pedido en un arreglo ordenado.
En el caso de que no haya un valor superior al pedido, nos entrega el último valor del arreglo.
Por ejemplo:
1  *upper_bound(v.begin(), v.end(), 30);    Valor de retorno: iterador al 40 (posición [4])</description>
    </item>
    
  </channel>
</rss>
