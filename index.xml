<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ZDoc</title>
    <link>/</link>
    <description>Recent content on ZDoc</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>&amp;copy;{year}, All Rights Reserved</copyright>
    
        <atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    
      
      <item>
        <title>Estructuras de datos</title>
        <link>/docs/estructuras-de-datos/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>/docs/estructuras-de-datos/</guid>
        <description>Table of Contents  Estructuras lineales Estructuras en forma de árbol    Estructuras lineales Acerca de Rellenar página
Arrays (arreglos) Los arrays son conjuntos de datos que se almacenan en memoria de manera contigua usando el mismo nombre. Se usan índices para diferenciar los distintos valores del arreglo.
Para crear una arreglo es necesario saber la cantidad de elementos que van a componer nuestro arreglo, pues la cantidad de elementos no se puede cambiar.</description>
      </item>
      
      <item>
        <title>Acerca de</title>
        <link>/docs/algoritmos-de-ordenamiento/info/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>/docs/algoritmos-de-ordenamiento/info/</guid>
        <description>Un algoritmo de ordenamiento es aquel que toma los elementos de una estructura y les asigna un orden. Cada algoritmo de ordenamiento tiene su forma de operar, y podría ayudar a conseguir la respuesta a un problema, no necesariamente por el resultado del ordenamiento.</description>
      </item>
      
      <item>
        <title>Acerca de</title>
        <link>/docs/algoritmos-de-busqueda/b%C3%BAsqueda-binaria/info/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>/docs/algoritmos-de-busqueda/b%C3%BAsqueda-binaria/info/</guid>
        <description>Table of Contents  Ejemplos    La búsqueda binaria es un algoritmo de divide and conquer (dividir y conquistar), que nos
permite encontrar un elemento dentro de una estructura ordenada
rápidamente. Al ejecutarse, toma el centro de un arreglo y comprueba si
el valor que se busca es igual al del centro. De no serlo, verifica si
el valor es menor o mayor al del centro.
Si el valor es mayor al del centro, se ignoran todos los valores</description>
      </item>
      
      <item>
        <title>Acerca de</title>
        <link>/docs/algoritmos-de-ordenamiento/algoritmos-de-decrecer-y-conquistar/info/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>/docs/algoritmos-de-ordenamiento/algoritmos-de-decrecer-y-conquistar/info/</guid>
        <description>Rellenar</description>
      </item>
      
      <item>
        <title>Acerca de</title>
        <link>/docs/algoritmos-de-ordenamiento/algoritmos-de-fuerza-bruta/info/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>/docs/algoritmos-de-ordenamiento/algoritmos-de-fuerza-bruta/info/</guid>
        <description>Rellenar</description>
      </item>
      
      <item>
        <title>Bubble sort</title>
        <link>/docs/algoritmos-de-ordenamiento/algoritmos-de-fuerza-bruta/bubble/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>/docs/algoritmos-de-ordenamiento/algoritmos-de-fuerza-bruta/bubble/</guid>
        <description>Table of Contents  Ejemplo Código de ejemplo:     Se van comparando los elementos, haciendo que los más grandes suban en el arreglo, como una burbuja. Da lo mismo cómo estén ordenadas las cosas, porque puedes modificar la función de comparación. Funciona invirtiendo el orden de cada par de elementos, si es que el primero es mayor que el segundo. Por ejemplo, se podría usar para contar el número de inversiones que hay que hacer.</description>
      </item>
      
      <item>
        <title>Selection sort</title>
        <link>/docs/algoritmos-de-ordenamiento/algoritmos-de-decrecer-y-conquistar/selection/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>/docs/algoritmos-de-ordenamiento/algoritmos-de-decrecer-y-conquistar/selection/</guid>
        <description> Table of Contents  Rellenar ejemplo Rellenar codigo de ejemplo     Tiene dos sub-arreglos, uno de elementos ya ordenados y uno de los elementos resantes. El arreglo ya ordenado parte vacío. Busca el valor mínimo entre los elementos no ordenados y lo añade al final de los ordenados.  Rellenar ejemplo Rellenar codigo de ejemplo </description>
      </item>
      
      <item>
        <title>Insertion sort</title>
        <link>/docs/algoritmos-de-ordenamiento/algoritmos-de-fuerza-bruta/insertion/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>/docs/algoritmos-de-ordenamiento/algoritmos-de-fuerza-bruta/insertion/</guid>
        <description>Table of Contents  Rellenar ejemplo Rellenar codigo de ejemplo     Se va de izquierda a derecha, se compara el segundo con el primero, se intercambian si el segundo es menor, si este es el caso, se vuelve a preguntar si el de la izquierda es menor al de mas a la izquierda y así hasta que se encuentre un caso en el que no o se llegue al principio del arreglo.</description>
      </item>
      
      <item>
        <title>Implementación con while</title>
        <link>/docs/algoritmos-de-busqueda/b%C3%BAsqueda-binaria/implementaciones-propias/con_while/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>/docs/algoritmos-de-busqueda/b%C3%BAsqueda-binaria/implementaciones-propias/con_while/</guid>
        <description>Esta implementación nos retorna el índice del número a buscar dentro de un arreglo.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  int binarySearch(int arr[], int l, int r, int x) { while (l &amp;lt;= r) { int m = l + (r - l) / 2; // Revisa si x esta al medio  if (arr[m] == x) return m; // Si x es mayor, ignorar la izquierda  if (arr[m] &amp;lt; x) l = m + 1; // Si x es menor, ignorar la derecha  else r = m - 1; } return -1; }    </description>
      </item>
      
      <item>
        <title>Implementación recursiva</title>
        <link>/docs/algoritmos-de-busqueda/b%C3%BAsqueda-binaria/implementaciones-propias/con_recursion/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>/docs/algoritmos-de-busqueda/b%C3%BAsqueda-binaria/implementaciones-propias/con_recursion/</guid>
        <description>Esta implementación nos retorna el índice del número a buscar dentro de un arreglo.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  int binarySearch(int arr[], int l, int r, int x) { if (r &amp;gt;= l) { int mid = l + (r - l) / 2; // Revisa si x esta al medio  if (arr[mid] == x) return mid; // Si x es mayor, ignorar la izquierda  if (arr[mid] &amp;gt; x) return binarySearch(arr, l, mid - 1, x); // Si x es mayor, ignorar la derecha  return binarySearch(arr, mid + 1, r, x); } return -1; }    </description>
      </item>
      
      <item>
        <title>Importar</title>
        <link>/docs/algoritmos-de-busqueda/b%C3%BAsqueda-binaria/en-la-stl/importar/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>/docs/algoritmos-de-busqueda/b%C3%BAsqueda-binaria/en-la-stl/importar/</guid>
        <description>Podemos directamente importar toda la stl o podemos importar la librería  de la
siguiente forma:
1  #include &amp;lt;algorithm&amp;gt;   </description>
      </item>
      
      <item>
        <title>binary_search()</title>
        <link>/docs/algoritmos-de-busqueda/b%C3%BAsqueda-binaria/en-la-stl/binary_search/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>/docs/algoritmos-de-busqueda/b%C3%BAsqueda-binaria/en-la-stl/binary_search/</guid>
        <description>La librería STL ya incluye binary search, si queremos saber si el valor
3 está en un vector, podemos ejecutar:
1 2 3 4 5 6 7  vector&amp;lt;int&amp;gt; v{1,2,5,7}; if (binary_search (v.begin(), v.end(), 3)) { cout &amp;lt;&amp;lt; &amp;#34;Se encuentra el valor 3 en nuestro vector\n&amp;#34;; } else { cout &amp;lt;&amp;lt; &amp;#34;No hay ningún 3 en nuestro vector\n&amp;#34;; }    Retorna un bool.</description>
      </item>
      
      <item>
        <title>upper_bound() (límite superior)</title>
        <link>/docs/algoritmos-de-busqueda/b%C3%BAsqueda-binaria/en-la-stl/lower_bound/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>/docs/algoritmos-de-busqueda/b%C3%BAsqueda-binaria/en-la-stl/lower_bound/</guid>
        <description>La función upper_bound() de la librería STL nos entrega un puntero a un valor
superior al pedido en un arreglo ordenado.
En el caso de que no haya un valor superior al pedido, nos entrega el
último valor del arreglo.
Por ejemplo:
1  *upper_bound(v.begin(), v.end(), 30);    Valor de retorno: iterador al 40 (posición [4])</description>
      </item>
      
    
  </channel>
</rss>