<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Apuntes YoC&#43; Comunitarios</title>
    <link>/</link>
    <description>Recent content on Apuntes YoC&#43; Comunitarios</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-cl</language><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Acerca de</title>
      <link>/Algoritmos-de-ordenamiento/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/info/</guid>
      <description>Cada algoritmo de ordenamiento tiene su forma de operar, y podría ayudar a conseguir la respuesta a un problema, no necesariamente por el resultado del ordenamiento.</description>
    </item>
    
    <item>
      <title>Acerca de</title>
      <link>/Algoritmos-de-ordenamiento/Algoritmos-de-decrecer-y-conquistar/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/Algoritmos-de-decrecer-y-conquistar/info/</guid>
      <description>Rellenar</description>
    </item>
    
    <item>
      <title>Acerca de</title>
      <link>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/info/</guid>
      <description>Rellenar</description>
    </item>
    
    <item>
      <title>Acerca de</title>
      <link>/estructuras-de-datos/estructuras-de-arboles/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-de-arboles/info/</guid>
      <description>Véase: arbol binario</description>
    </item>
    
    <item>
      <title>Acerca de</title>
      <link>/estructuras-de-datos/estructuras-lineales/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/info/</guid>
      <description>Rellenar página</description>
    </item>
    
    <item>
      <title>Bubble sort</title>
      <link>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/bubble/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/bubble/</guid>
      <description>Table of Contents  Ejemplo Código de ejemplo:     Se van comparando los elementos, haciendo que los más grandes suban en el arreglo, como una burbuja. Da lo mismo cómo estén ordenadas las cosas, porque puedes modificar la función de comparación. Funciona invirtiendo el orden de cada par de elementos, si es que el primero es mayor que el segundo. Por ejemplo, se podría usar para contar el número de inversiones que hay que hacer.</description>
    </item>
    
    <item>
      <title>Selection sort</title>
      <link>/Algoritmos-de-ordenamiento/Algoritmos-de-decrecer-y-conquistar/selection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/Algoritmos-de-decrecer-y-conquistar/selection/</guid>
      <description> Table of Contents  Rellenar ejemplo Rellenar codigo de ejemplo     Tiene dos sub-arreglos, uno de elementos ya ordenados y uno de los elementos resantes. El arreglo ya ordenado parte vacío. Busca el valor mínimo entre los elementos no ordenados y lo añade al final de los ordenados.  Rellenar ejemplo Rellenar codigo de ejemplo </description>
    </item>
    
    <item>
      <title>Set (conjunto)</title>
      <link>/estructuras-de-datos/estructuras-de-arboles/set/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-de-arboles/set/</guid>
      <description>Table of Contents  Inicialización insert (Insertar) find (Encontrar) erase (borrar) Iterar a través de un conjunto    No permite que hayan elementos repetidos.
Inicialización Incluimos la librería:
1  #include &amp;lt;set&amp;gt;   Inicializamos nuestro conjunto:
2  set &amp;lt; int &amp;gt; conjunto; // int puede ser reemplazado con cualquier otro tipo de dato    insert (Insertar) Inserta un dato. Retorna un par de elementos, el primero siendo el iterador del valor insertado y el segundo siendo un bool que marca si es que ya existía o no.</description>
    </item>
    
    <item>
      <title>Vectores</title>
      <link>/estructuras-de-datos/estructuras-lineales/vectors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/vectors/</guid>
      <description>Table of Contents  Asignar un valor push back (empujar atrás) pop back (quitar atrás) insert (insertar) erase (borrar)    Los vectores son como arreglos, excepto de que el tamaño es dinámico, es decir, se puede cambiar. Incluimos la librería:
1  #include &amp;lt;vector&amp;gt;   Inicializamos nuestro vector &amp;ldquo;vec&amp;rdquo;:
2 3  int n = 3; vector &amp;lt; int &amp;gt; vec(n, 0); // Inicializa un vector de tamaño 3 con todos sus valores = 0.</description>
    </item>
    
    <item>
      <title>Insertion sort</title>
      <link>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/insertion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/insertion/</guid>
      <description>Table of Contents  Rellenar ejemplo Rellenar codigo de ejemplo     Se va de izquierda a derecha, se compara el segundo con el primero, se intercambian si el segundo es menor, si este es el caso, se vuelve a preguntar si el de la izquierda es menor al de mas a la izquierda y así hasta que se encuentre un caso en el que no o se llegue al principio del arreglo.</description>
    </item>
    
    <item>
      <title>Map (mapa, tabla de hashing)</title>
      <link>/estructuras-de-datos/estructuras-de-arboles/map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-de-arboles/map/</guid>
      <description>Table of Contents  Ejemplo cotidiano Inicializar Insert (insertar) Operar con los valores Find (encontrar) Erase (borrar) Recorrer los valores de un mapa Dudas que no dejan dormir    Toma dos datos, una llave y un valor. Puedes buscar una llave en tiempo logarítmico con la implementación de la STL. Pero con otras implementaciones se puede hacer en tiempo constante. Las llaves no se pueden repetir.
Ejemplo cotidiano Libros:</description>
    </item>
    
    <item>
      <title>Stacks (pilas)</title>
      <link>/estructuras-de-datos/estructuras-lineales/stacks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/stacks/</guid>
      <description>Table of Contents  push (empujar) top (cima) pop (quitar) empty (vacío) size (tamaño)    La pila es una estructura de datos lineal al que sólo puedes acceder al último elemento que fue insertado. Imagina una pila de platos, por ejemplo.
1  stack &amp;lt; int &amp;gt; pilita;    push (empujar) Empuja un dato a la cima de la pila.
2  pilita.push(8); // Empuja un 8 a la cima de la pila.</description>
    </item>
    
    <item>
      <title>Queues (colas)</title>
      <link>/estructuras-de-datos/estructuras-lineales/queues/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/queues/</guid>
      <description>Table of Contents  push (empujar) front (frente) pop (quitar) empty (vacío) size (tamaño)    La cola es una estructura de datos lineal al que sólo puedes acceder al primer elemento que fue insertado. Imagina una fila de una caja de un supermercado, por ejemplo.
1  queue &amp;lt; int &amp;gt; colita;    push (empujar) Añade un dato al final de la cola.
2 3 4 5 6  colita.</description>
    </item>
    
  </channel>
</rss>
