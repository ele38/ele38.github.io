<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Apuntes YoC&#43; Comunitarios</title>
    <link>/</link>
    <description>Recent content on Apuntes YoC&#43; Comunitarios</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>es-cl</language><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Acerca de</title>
      <link>/Algoritmos-de-ordenamiento/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/info/</guid>
      <description>Cada algoritmo de ordenamiento tiene su forma de operar, y podría ayudar a conseguir la respuesta a un problema, no necesariamente por el resultado del ordenamiento.</description>
    </item>
    
    <item>
      <title>Acerca de</title>
      <link>/Algoritmos-de-ordenamiento/Algoritmos-de-decrecer-y-conquistar/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/Algoritmos-de-decrecer-y-conquistar/info/</guid>
      <description>Rellenar</description>
    </item>
    
    <item>
      <title>Acerca de</title>
      <link>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/info/</guid>
      <description>Rellenar</description>
    </item>
    
    <item>
      <title>Acerca de</title>
      <link>/estructuras-de-datos/estructuras-de-arboles/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-de-arboles/info/</guid>
      <description>Véase: arbol binario</description>
    </item>
    
    <item>
      <title>Acerca de</title>
      <link>/estructuras-de-datos/estructuras-lineales/info/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/info/</guid>
      <description>Rellenar página</description>
    </item>
    
    <item>
      <title>Arrays (arreglos)</title>
      <link>/estructuras-de-datos/estructuras-lineales/arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/arrays/</guid>
      <description>Table of Contents  Inicialización Leer el valor de un arreglo Asignar valores a un arreglo    Los arrays son conjuntos de datos que se almacenan en memoria de manera contigua usando el mismo nombre. Se usan índices para diferenciar los distintos valores del arreglo. Para crear una arreglo es necesario saber la cantidad de elementos que van a componer nuestro arreglo, pues la cantidad de elementos no se puede cambiar.</description>
    </item>
    
    <item>
      <title>Bubble sort</title>
      <link>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/bubble/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/bubble/</guid>
      <description>Table of Contents  Ejemplo Código de ejemplo:     Se van comparando los elementos, haciendo que los más grandes suban en el arreglo, como una burbuja. Da lo mismo cómo estén ordenadas las cosas, porque puedes modificar la función de comparación. Funciona invirtiendo el orden de cada par de elementos, si es que el primero es mayor que el segundo. Por ejemplo, se podría usar para contar el número de inversiones que hay que hacer.</description>
    </item>
    
    <item>
      <title>Selection sort</title>
      <link>/Algoritmos-de-ordenamiento/Algoritmos-de-decrecer-y-conquistar/selection/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/Algoritmos-de-decrecer-y-conquistar/selection/</guid>
      <description> Table of Contents  Rellenar ejemplo Rellenar codigo de ejemplo     Tiene dos sub-arreglos, uno de elementos ya ordenados y uno de los elementos resantes. El arreglo ya ordenado parte vacío. Busca el valor mínimo entre los elementos no ordenados y lo añade al final de los ordenados.  Rellenar ejemplo Rellenar codigo de ejemplo </description>
    </item>
    
    <item>
      <title>Set (conjunto)</title>
      <link>/estructuras-de-datos/estructuras-de-arboles/set/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-de-arboles/set/</guid>
      <description>Table of Contents  Inicialización insert (Insertar) find (Encontrar) erase (borrar) Iterar a través de un conjunto    Es una lista que no permite que hayan elementos repetidos.
Inicialización Incluimos la librería:
1  #include &amp;lt;set&amp;gt;   Inicializamos nuestro conjunto:
2  set &amp;lt; int &amp;gt; conjunto; // int puede ser reemplazado con cualquier otro tipo de dato    insert (Insertar) Inserta un dato. Retorna un par de elementos, el primero siendo el iterador del valor insertado y el segundo siendo un bool que marca si es que ya existía o no.</description>
    </item>
    
    <item>
      <title>Arrays multidimensionales</title>
      <link>/estructuras-de-datos/estructuras-lineales/multi-dimension-arrays/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/multi-dimension-arrays/</guid>
      <description>Table of Contents  Inicializar un arreglo multidimensional Asignar valores en un arreglo multidimensional    Un array multidimensional es aquel que requiuere de más de un índice para ser llamado, como su nombre lo indica, es útil para cuando necesitamos acceder a datos que requieren más de una dimensión, como por ejemplo valores dentro de una malla. Otra forma de enternder los arrays multidimensionales es como un arreglo de arreglos (de arreglos de arreglos.</description>
    </item>
    
    <item>
      <title>Insertion sort</title>
      <link>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/insertion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/Algoritmos-de-ordenamiento/Algoritmos-de-fuerza-bruta/insertion/</guid>
      <description>Table of Contents  Rellenar ejemplo Rellenar codigo de ejemplo     Se va de izquierda a derecha, se compara el segundo con el primero, se intercambian si el segundo es menor, si este es el caso, se vuelve a preguntar si el de la izquierda es menor al de mas a la izquierda y así hasta que se encuentre un caso en el que no o se llegue al principio del arreglo.</description>
    </item>
    
    <item>
      <title>Map (mapa, tabla de hashing)</title>
      <link>/estructuras-de-datos/estructuras-de-arboles/map/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-de-arboles/map/</guid>
      <description>Table of Contents  Ejemplo cotidiano Inicializar Insert (insertar) Operar con los valores Find (encontrar) Erase (borrar) Recorrer los valores de un mapa Dudas que no dejan dormir    Toma dos datos, una llave y un valor. Puedes buscar una llave en tiempo logarítmico con la implementación de la STL. Pero con otras implementaciones se puede hacer en tiempo constante. Las llaves no se pueden repetir.
Ejemplo cotidiano Libros:</description>
    </item>
    
    <item>
      <title>Vectors (vectores)</title>
      <link>/estructuras-de-datos/estructuras-lineales/vectors/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/vectors/</guid>
      <description>Table of Contents  Inicializar un vector Asignar un valor push back (empujar atrás) pop back (quitar atrás) insert (insertar) erase (borrar) Iteradores de un arreglo    Los vectores son como arreglos, excepto de que el tamaño es dinámico, es decir, se puede cambiar.
Inicializar un vector Incluimos la librería:
1  #include &amp;lt;vector&amp;gt;   Inicializamos nuestro vector &amp;ldquo;vec&amp;rdquo;:
2 3  int n = 3; vector &amp;lt; int &amp;gt; vec(n, 0); // Inicializa un vector de tamaño 3 con todos sus valores = 0.</description>
    </item>
    
    <item>
      <title>Stacks (pilas)</title>
      <link>/estructuras-de-datos/estructuras-lineales/stacks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/stacks/</guid>
      <description>Table of Contents  push (empujar) top (cima) pop (quitar) empty (vacío) size (tamaño)    La pila es una estructura de datos lineal al que sólo puedes acceder al último elemento que fue insertado. Imagina una pila de platos, por ejemplo.
1  stack &amp;lt; int &amp;gt; pilita;    push (empujar) Empuja un dato a la cima de la pila.
2  pilita.push(8); // Empuja un 8 a la cima de la pila.</description>
    </item>
    
    <item>
      <title>Queues (colas)</title>
      <link>/estructuras-de-datos/estructuras-lineales/queues/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/estructuras-de-datos/estructuras-lineales/queues/</guid>
      <description>Table of Contents  push (empujar) front (frente) pop (quitar) empty (vacío) size (tamaño)    La cola es una estructura de datos lineal al que sólo puedes acceder al primer elemento que fue insertado. Imagina una fila de una caja de un supermercado, por ejemplo.
1  queue &amp;lt; int &amp;gt; colita;    push (empujar) Añade un dato al final de la cola.
2 3 4 5 6  colita.</description>
    </item>
    
  </channel>
</rss>
